<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>GALAXY 10^6</title>
  <style>
    :root{color-scheme:dark;}
    html,body{margin:0;height:100%;background:#000;overflow:hidden;}
    canvas{display:block;width:100%;height:100%;}
    .tag{
      position:fixed;right:14px;top:14px;
      padding:10px 14px;border-radius:999px;
      background:rgba(10,14,20,.55);border:1px solid rgba(255,255,255,.15);
      color:#e6edf3;font:600 12px/1 system-ui,Segoe UI,Meiryo,sans-serif;
      backdrop-filter: blur(8px);
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div class="tag">GALAXY 10^6 / SHADER</div>

  <script>
  (function(){
    const canvas = document.getElementById("c");
    const gl = canvas.getContext("webgl", { antialias:false, premultipliedAlpha:false });
    if(!gl){ document.body.innerHTML="WebGL not supported"; return; }

    const vsSrc = `
      attribute vec2 aPos;
      void main(){ gl_Position = vec4(aPos, 0.0, 1.0); }
    `;

    // “銀河っぽい”やつ：極座標 + 渦 + スターフィールド（簡易）
    const fsSrc = `
      precision highp float;
      uniform vec2  uRes;
      uniform float uTime;

      float hash(vec2 p){
        p = fract(p*vec2(123.34, 456.21));
        p += dot(p, p+34.345);
        return fract(p.x*p.y);
      }

      float noise(vec2 p){
        vec2 i=floor(p), f=fract(p);
        float a=hash(i);
        float b=hash(i+vec2(1.0,0.0));
        float c=hash(i+vec2(0.0,1.0));
        float d=hash(i+vec2(1.0,1.0));
        vec2 u=f*f*(3.0-2.0*f);
        return mix(a,b,u.x) + (c-a)*u.y*(1.0-u.x) + (d-b)*u.x*u.y;
      }

      void main(){
        vec2 uv = (gl_FragCoord.xy - 0.5*uRes) / min(uRes.x,uRes.y);
        float t = uTime;

        float r = length(uv);
        float a = atan(uv.y, uv.x);

        // スパイラル
        float swirl = a + 2.5*log(r + 1e-3) - 0.9*t;
        float bands = 0.5 + 0.5*sin(10.0*swirl);

        // コア輝度（中心が強いので後で抑えたければ係数を下げる）
        float core = exp(-6.0*r*r);

        // 微粒子（星）
        vec2 p = uv*220.0 + vec2(t*8.0, -t*5.0);
        float n = noise(p);
        float stars = smoothstep(0.985, 1.0, n);

        // カラーバランス
        vec3 col = vec3(0.0);
        col += vec3(0.2,0.35,0.9) * (1.0-r)*0.25;              // 外縁
        col += vec3(1.0,0.4,0.2) * bands * (0.35/(r+0.12));   // アーム
        col += vec3(1.2,0.8,1.6) * core * 2.0;                // コア
        col += vec3(1.0) * stars * 0.9;                       // 星

        // 周辺減光
        col *= smoothstep(1.2, 0.0, r);

        // ちょいトーンマップ
        col = col / (1.0 + col);

        gl_FragColor = vec4(col, 1.0);
      }
    `;

    function compile(type, src){
      const s = gl.createShader(type);
      gl.shaderSource(s, src);
      gl.compileShader(s);
      if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){
        console.error(gl.getShaderInfoLog(s));
        throw new Error("shader compile failed");
      }
      return s;
    }
    function link(vs, fs){
      const p = gl.createProgram();
      gl.attachShader(p, vs);
      gl.attachShader(p, fs);
      gl.linkProgram(p);
      if(!gl.getProgramParameter(p, gl.LINK_STATUS)){
        console.error(gl.getProgramInfoLog(p));
        throw new Error("program link failed");
      }
      return p;
    }

    const vs = compile(gl.VERTEX_SHADER, vsSrc);
    const fs = compile(gl.FRAGMENT_SHADER, fsSrc);
    const prog = link(vs, fs);

    const buf = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buf);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
      -1,-1,  1,-1, -1, 1,
      -1, 1,  1,-1,  1, 1
    ]), gl.STATIC_DRAW);

    const aPos = gl.getAttribLocation(prog, "aPos");
    const uRes = gl.getUniformLocation(prog, "uRes");
    const uTime= gl.getUniformLocation(prog, "uTime");

    function resize(){
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      const w = Math.floor(innerWidth  * dpr);
      const h = Math.floor(innerHeight * dpr);
      if(canvas.width!==w || canvas.height!==h){
        canvas.width = w; canvas.height = h;
        gl.viewport(0,0,w,h);
      }
    }
    window.addEventListener("resize", resize);

    // クリックでフルスクリーン（失敗しても無視）
    window.addEventListener("click", () => {
      if(document.fullscreenElement) document.exitFullscreen?.();
      else canvas.requestFullscreen?.();
    });

    const t0 = performance.now();
    function draw(now){
      resize();
      gl.useProgram(prog);
      gl.bindBuffer(gl.ARRAY_BUFFER, buf);
      gl.enableVertexAttribArray(aPos);
      gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);
      gl.uniform2f(uRes, canvas.width, canvas.height);
      gl.uniform1f(uTime, (now - t0) * 0.001);
      gl.drawArrays(gl.TRIANGLES, 0, 6);
      requestAnimationFrame(draw);
    }
    requestAnimationFrame(draw);
  })();
  </script>
</body>
</html>
